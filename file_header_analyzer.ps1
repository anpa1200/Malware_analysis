# Prompt the user for the file path
$file_path = Read-Host "Enter the file path"

# Check if file exists
if (-not (Test-Path $file_path)) {
    Write-Error "File not found."
    return
}

# Read the file in binary mode
$file_bytes = [System.IO.File]::ReadAllBytes($file_path)

# Function to determine file type based on magic number
function GetFileType($bytes) {
    $hexString = [BitConverter]::ToString($bytes) -replace '-'
    
    switch ($hexString.Substring(0,8)) {
        "4D5A9000" { return "PE (Portable Executable)" }
        "25504446" { return "PDF" }
        "504B0304" { return "ZIP" }
        "424D" { return "Bitmap" }
        "47494638" { return "GIF" }
        "89504E47" { return "PNG" }
        "494433" { return "MP3" }
        "52494646" { return "WAV" }
        "464C5601" { return "FLV" }
        "FFD8" { return "JPEG" }
        "49492A00" { return "TIFF" }
        "00000018" { return "QuickTime" }
        "00000014" { return "ISO Base Media" }
        "4F676753" { return "OGG" }
        "49536328" { return "ISC" }
        default { return "Unknown" }
    }
}

# Function to compute various hashes
function ComputeHashes($file_path) {
    $hashes = @{}

    $hashTypes = @('MD5', 'SHA1', 'SHA256')
    foreach ($hashType in $hashTypes) {
        $crypto = [System.Security.Cryptography.HashAlgorithm]::Create($hashType)
        $hash = $crypto.ComputeHash($file_bytes)
        $hashString = [BitConverter]::ToString($hash) -replace '-'
        $hashes[$hashType] = $hashString
    }

    return $hashes
}

# Identify file type
$file_type = GetFileType -bytes $file_bytes[0..15]
Write-Host "File Type: $file_type"

# Extract File Size
$file_size = (Get-Item $file_path).length
Write-Host "File Size: $file_size bytes"

# Compute and display hashes
$hashes = ComputeHashes -file_path $file_path
$hashes.GetEnumerator() | ForEach-Object { Write-Host "$($_.Key): $($_.Value)" }

# If the file is a PE file, extract the e_lfanew field from the DOS header and get the TimeDateStamp
if ($file_type -eq "PE (Portable Executable)") {
    # Extract e_lfanew field value from DOS header
    $e_lfanew = [BitConverter]::ToInt32($file_bytes[60..63], 0)

    # Extract TimeDateStamp from PE header
    $timestamp_offset = $e_lfanew + 8
    $timestamp = [BitConverter]::ToUInt32($file_bytes[$timestamp_offset..($timestamp_offset+3)], 0)

    # Convert TimeDateStamp to date
    $epoch_start = Get-Date "1970-01-01 00:00:00"
    $pe_date = $epoch_start.AddSeconds($timestamp)

    Write-Host "TimeDateStamp: $pe_date"
}
Read-Host "Press Enter to exit..."
